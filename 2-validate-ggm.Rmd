---
title: "GGM Validation"
output: html_notebook
author: Johann Hawe
---
# contingency table per locus for snp mediation

This script is used to validate already calculated ggm fits.
The fitted ggm models are loaded and validated using the concept of individual
link types, i.e. cpg-gene links, snp-gene links and gene-gene links.

```{r}
library(graph)
library(data.table)
library(GenomicRanges)
library(TxDb.Hsapiens.UCSC.hg19.knownGene)
library(psych)
library(Homo.sapiens)
source("R/validation.R")
source("R/lib.R")
```

## Data preparation
Before starting prepare the needed data, i.e. the ggm fit, the ranges originally
used and the original data.matrix. We als retrieve the different set of entities,
i.e. the snp, the cpgs as well as the respective locus genes, tfs and shortest path
genes. Those entities can either have been selected via ggm graph or not.

```{r}
# learn on kora -> validate on lolipop? since we use the same data for creating 
# the model

# prepare data
load("results/ggm.fit.lolipop.RData")
# load both kora and lollipop data (for gene mediation)
env <- new.env()
load("data/kora/rs9859077.data.RData", envir=env)
kdata <- with(env, sentinel$data)
load("data/lolipop/rs9859077.data.RData", envir=env)
ldata <- with(env, sentinel$data)

# ensure the same entities in both data sets
# dnodes -> full set of possible nodes
dnodes <- intersect(colnames(ldata), colnames(kdata))
ldata <- ldata[,dnodes]
kdata <- kdata[,dnodes]

# for now we use the kora data for validation since 
# the current fit was calculated on lolipop
data <- kdata

# the nodes retained in the fitted graph model
gnodes <- nodes(graph)

# for now, filter only for those nodes for which data was available
# should change once we update the data matrix...
gnodes <- gnodes[gnodes %in% colnames(dnodes)]
# get names of all entities, total and selected by ggm
snp <- names(ranges$sentinel.range)
data[,snp] <- as.integer(as.character(data[,snp]))
cpgs <- intersect(dnodes, names(ranges$cpgs))
cpgs.selected <- cpgs[cpgs %in% gnodes]
all.genes <- colnames(data)[!grepl("^rs|^cg", colnames(data))]
sgenes <- intersect(dnodes, ranges$snp.genes$SYMBOL)
sgenes.selected <- sgenes[sgenes %in% unlist(adj(graph,snp))]
cgenes <- intersect(dnodes, ranges$cpg.genes$SYMBOL)
cgenes.selected <- cgenes[cgenes %in% unlist(adj(graph,cpgs))]

# TODO adjust this for new data
# TODO also check TF to cpg-gene association..
tfs <- intersect(dnodes, ranges$tfs$SYMBOL)
tfs.selected <- tfs[tfs %in% unlist(adj(graph,cpgs))]
tfs.selected

# the shortest path genes
spath <- ranges$spath$SYMBOL
spath.selected <- spath[spath %in% gnodes]

cat("Summary on number of genes, total vs selected via ggm:\n")
cat("sgenes\t", length(sgenes),"\t", length(sgenes.selected), "\n")
cat("cgenes\t", length(cgenes),"\t", length(cgenes.selected), "\n")
cat("tfs\t", length(tfs),"\t", length(tfs.selected), "\n")
cat("spath\t", length(spath),"\t", length(spath.selected), "\n")

```
Above the number of snp genes (sgenes), cpg genes (cgenes), transcription
factors (tfs) as well as the genes on the shortest paths between tfs and sgenes (spath)
are shown. Starting from those set definitions, we now perform the validation of the model.

## SNP-gene validation
For the SNP-gene validation for which we have several approaches:

1. Perform gene mediation. 
Here we check for each gene individually, whether it likely
mediates the effect the sentinel snp has on the defined trans-cpgs. We calculate linear models
between snp/genes, snp/cpgs and genes/cpgs. The $\beta$ of the linear models should add up, i.e.
$\beta_{sc} = \beta_{sg}*\beta_{gc}$. For each gene we get as a result the correlation between
the $\beta_{sc}$ and $\beta_{sg}*\beta_{gc}$ over all CpGs.
2. Check cis-eQTLs. Here we check whether the selected SNP genes (connected to the sentinel) 
are cis-eQTLs in an independent study (Joehanes et al. 2017). The more selected genes are cis-eQTLs
as compared to the not selected ones, the more significant is the selection of genes in our models.
3. check whether SNPs are in TFBS (in case of >1 SNPs)
4. ChromHMM states for SNPs (in case of >1 SNPs)
concept.

```{r}
# (1) Perform mediation analysis
# mediation over all snp genes
med <- mediation(data, snp, sgenes, cpgs )
# mediation for only ggm selected snp genes
med.selected <- med[sgenes.selected]
# mediation for only not selected snp genes
med <- med[setdiff(sgenes,sgenes.selected)]

# TODO if we choose to do a test for comparing 
# selected/not selected, check assumptions first

# min mediation pv for all not selected snpgenes
med.pv <- min(unlist(lapply(med, "[[", "pvalue")))
# max mediation pv for selected snpgenes
med.pv.selected <- max(unlist(lapply(med.selected, "[[", "pvalue")))

cat("Mediation result summary (min/max of pvals):\n")
cat("not selected\tselected\n")
cat(med.pv, "\t", med.pv.selected)
cat("Difference (log10(ns/s)): ", log10(med.pv/med.pv.selected))

# (2) check cis-eQTL in independent study
# load cis-eQTL data
ceqtl <- fread("zcat data/joehanes-et-al-2017/eqtls/eqtl-gene-annot_cis-only.txt.gz",
               sep=",", 
               data.table=F, select = c("SNP_Chr","SNP_Pos_hg19","Rs_ID","SNP_MAF","SNP_Imputation_RSq","ProbesetID","Transcript_Chr","Transcript_GeneSymbol","Transcript_EntrezGeneID","Is_Cis","log10FDR"))
# get only cis eqtlas defined in the paper
ceqtl <- ceqtl[ceqtl$Is_Cis==1,,drop=F]
cat("Loaded ", nrow(ceqtl), " cis-eQTL\n")
head(ceqtl)

# filter ceqtl to be only related to our sentinel SNP
# TODO use proxy/high ld snps to increase ceqtl number?
ceqtl <- ceqtl[ceqtl$Rs_ID %in% snp,,drop=F]
ceqtl.sgenes <- sgenes[sgenes %in% ceqtl$Transcript_GeneSymbol]
ceqtl.sgenes.selected <- intersect(ceqtl.sgenes, sgenes.selected)
ceqtl.sgenes
ceqtl.sgenes.selected
# create matrix for fisher test
cont <- matrix(c(length(ceqtl.sgenes),length(ceqtl.sgenes.selected),
                 length(sgenes),length(sgenes.selected)),
               nrow=2,ncol=2, byrow = T)
rownames(cont) <- c("ceqtl", "no ceqtl")
colnames(cont) <- c("not selected", "selected")
cont
fisher.test(cont)

# (1) load chromHMM annotation (SNP annotation)
## not yet needed


# (3) SNPs in TFBS
## not yet needed

```

## CpG-gene and TF-CpG validation
The next step is validating the cpg-gene and cpg-tf links. For this we use 3 approaches:
1. check trans-eQTL in independent dataset. Here we found the paper of [Joehanes et al. 2017
in Genome Biology](https://genomebiology.biomedcentral.com/articles/10.1186/s13059-016-1142-6)
2. check epigenetic annotation (implies change in currently performed prior calculation)
3. check CpGs in TFBS (split cell-lines for priors/validation).
```{r}
# load the trans-eQTL dataset
teqtl <- fread("zcat data/joehanes-et-al-2017/eqtls/eqtl-gene-annot_trans-only_logFDR2.txt.gz", 
               sep=",", 
               data.table=F, select = c("SNP_Chr","SNP_Pos_hg19","Rs_ID","SNP_MAF","SNP_Imputation_RSq","ProbesetID","Transcript_Chr","Transcript_GeneSymbol","Transcript_EntrezGeneID","Is_Cis","log10FDR"))
# sanity check
cat("only trans: ", all(teqtl$Is_Cis == 0), "\n")
head(teqtl)

# filter teqtl to be only related to our sentinel SNP
# TODO use proxy/high ld snps to increase teqtl number?
teqtl <- teqtl[teqtl$Rs_ID %in% snp,,drop=F]
teqtl.cgenes <- cgenes[cgenes %in% teqtl$Transcript_GeneSymbol]
teqtl.cgenes.selected <- intersect(teqtl.cgenes, cgenes.selected)

cat("CpG genes: ", cgenes, "\n")
cat("CpG genes with trans-eQTL: ", teqtl.cgenes, "\n")
cat("selected CpG genes with trans-eQTL: ", teqtl.cgenes.selected, "\n")

# create matrix for fisher test
cont <- matrix(c(length(teqtl.cgenes),length(teqtl.cgenes.selected),
                 length(cgenes),length(cgenes.selected)),
               nrow=2,ncol=2, byrow = T)
cat("confusion matrix for cgenes:\n")
rownames(cont) <- c("teqtl", "no teqtl")
colnames(cont) <- c("not selected", "selected")
cont
fisher.test(cont)

# analyze the tfs, total and selected
teqtl.tfs <- tfs[tfs %in% teqtl$Transcript_GeneSymbol]
teqtl.tfs.selected <- intersect(teqtl.tfs, tfs.selected)

cat("TFs: ", tfs, "\n")
cat("TFs with trans-eQTL: ", teqtl.tfs, "\n")
cat("selected TFs with trans-eQTL: ", teqtl.tfs.selected, "\n")
# create matrix for fisher test
cont <- matrix(c(length(teqtl.tfs),length(teqtl.tfs.selected),
                 length(tfs),length(tfs.selected)),
               nrow=2,ncol=2, byrow = T)
cat("confusion matrix for TFs:\n")
rownames(cont) <- c("teqtl", "no teqtl")
colnames(cont) <- c("not selected", "selected")
cont
fisher.test(cont)

```

## Gene-Gene validation
Finally we perform the gene-gene validation:
1. check co-expression in independent data. 
2. gene set enrichment
3. check co-citation 

For the co-expression analysis we load the data from Geuvadis (Lappaleinen et al.),
this is gene expression data from 462 LCL cell-lines. The data already is normalized
to RPKMs and technical artifacts are removed (using PEER factors). We currently
calculated correlations only on the subset of genes which is within our network.
```{r cache=TRUE}
# load the expression data from geuvadis/lappaleinen
#geu <- fread("zcat data/expression/GD462.GeneQuantRPKM.50FN.samplename.resk10.txt.gz", header=T,
geu <- fread("zcat data/expression/GD660.GeneQuantRPKM.txt.gz", header=T,
             data.table=F)
geneinfo <- geu[,1:4]
# get the gene symbols
geneinfo$Gene_Symbol <- mapIds(Homo.sapiens, unlist(lapply(strsplit(geneinfo[,1], "\\."), "[",1)), "SYMBOL", keytype="ENSEMBL")
drop <- is.na(geneinfo$Gene_Symbol)
geneinfo <- geneinfo[!drop,]
geu <- geu[!drop,-(1:4)]

# quantile normalize 
scaled <- geu
rownames(scaled) = geneinfo[,"TargetID"]
rownames(scaled) = sapply(strsplit(rownames(scaled), ".", fixed=T), "[", 1)
scaled = normalize.quantile(scaled)
# match the sample ids 
sample.id = sapply(strsplit(colnames(scaled), ".", fixed=T), "[", 1)
mean.expr = t(apply(scaled, 1, tapply, sample.id, mean))

## transform the scaled counts to std normal per gene
stdnorm <- function(x) {
  r = rank(x, ties.method="random")
  qnorm(r / (length(x) + 1))
}
transformed = apply(mean.expr, 1, stdnorm)
corrected <- get.peer.factors(transformed, get.residuals = T, Nk = 10)
colnames(corrected) <- geneinfo$Gene_Symbol
min(corrected)
max(corrected)

```
Dimension of the gene expression matrix is `r dim(rpkm)`. We first check the distribution
of the expression of some randomly selected genes.

```{r}
par(mfrow=c(2,2))
set.seed(42)
hist(corrected[sample(1:nrow(corrected),1),], breaks=50, xlab="expression", main="histogram 1")
hist(corrected[sample(1:nrow(corrected),1),], breaks=50, xlab="expression", main="histogram 2")
hist(corrected[sample(1:nrow(corrected),1),], breaks=50, xlab="expression", main="histogram 3")
hist(corrected[sample(1:nrow(corrected),1),], breaks=50, xlab="expression", main="histogram 4")

#TODO histogram shows few very large values -> handle?
```

Look at those histograms....

Now, for each gene we calculate the correlation against each other gene in our set
over all samples. In the end we want to boil this down to 'significant' correlations,
hence we collect FDR corrected p-values using the psych package.

```{r}
# get the gene-gene links which are possible in our graph
em <- expand.grid(all.genes, all.genes, stringsAsFactors = F)
em <- (em[em$Var1 != em$Var2, ])
# remove duplicated entries
em.names <- vector(mode="character", length=nrow(em))
for(i in 1:nrow(em)){
  em.names[i] <- paste0(sort(c(em[i,1], em[i,2])), collapse="")
}
em <- em[!duplicated(em.names),]

#em <- em[1:(nrow(em)/2),]
em <- cbind(em[,1], em[,2])
em <- as.data.frame(em, stringsAsFactors=F)
em

# get the gene-gene links which can be found in our graph
em.selected <- t(edgeMatrix(graph))
em.selected <- cbind(gnodes[em.selected[,1]], gnodes[em.selected[,2]])
em.selected <- em.selected[!grepl("^rs|^cg", em.selected[,1]),]
em.selected <- em.selected[!grepl("^rs|^cg", em.selected[,2]),]
colnames(em) <- colnames(em.selected) <- c("n1", "n2")
em.selected <- as.data.frame(em.selected, stringsAsFactors=F)
em.selected

# get the gene-gene sign correlations from the lappal. data
totest <- corrected[,geneinfo$Gene_Symbol %in% colnames(data)]
totest.symbols <- colnames(totest)
if(any(duplicated(totest.symbols))){
  # TODO merge the data, i.e. take rpkm means or similar if necessary...
  warning("This should not be happening, duplicated gene symbols.")
}
cat("Checking", ncol(totest), "genes for correlation.\n")
pvs <- lapply(1:nrow(em), function(r){
  n1 <- em[r,1]
  n2 <- em[r,2]
  # check whether we have data for both nodes
  if(n1 %in% colnames(data) & n2 %in% colnames(data)){
    res <- cor.test(data[,n1], data[,n2])
    c(n1,n2,res$p.value, res$estimate)
  } else {
    c(n1,n2,NA)
  }
})
pvs <- as.data.frame(matrix(unlist(pvs), ncol=4, byrow = T), stringsAsFactors=F)
colnames(pvs) <- c("n1", "n2", "pval", "cor")
pvs$pval <- as.numeric(pvs$pval)
pvs$cor <- as.numeric(pvs$cor)

# upper diagonal of p contains the adjusted pvalues
hist(pvs$pval, main="correlations between genes")

library(qvalue)
pvs <- cbind(pvs, qval=qvalue(pvs$pval)$qvalues)
sign.cors <- pvs[pvs$qval<0.01 & abs(pvs$cor>0.5),]

em.sign <- em[(em$n1 %in% sign.cors$n1 & em$n2 %in% sign.cors$n2)
              | (em$n2 %in% sign.cors$n1 & em$n1 %in% sign.cors$n2),]
em.selected.sign <- em.selected[(em.selected$n1 %in% sign.cors$n1 & em.selected$n2 %in% sign.cors$n2)
              | (em.selected$n2 %in% sign.cors$n1 & em.selected$n1 %in% sign.cors$n2),]

# create matrix for fisher test
cont <- matrix(c(nrow(em.sign),nrow(em.selected.sign),
                 nrow(em),nrow(em.selected)),
               nrow=2,ncol=2, byrow = T)
cat("confusion matrix for gene_gene links:\n")
rownames(cont) <- c("sign", "not sign")
colnames(cont) <- c("not selected", "selected")
print(cont)


```


