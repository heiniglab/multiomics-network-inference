---
title: "GGM Validation"
output: html_notebook
author: Johann Hawe
---

This script is used to validate already calcaulted ggm fits.
The fitted ggm models are loaded and validated using the concept of individual
link types, i.e. cpg-gene links, snp-gene links and gene-gene links.

```{r}
library(graph)
library(data.table)
library(TxDb.Hsapiens.UCSC.hg19.knownGene)
library(psych)
library(Homo.sapiens)
source("R/validation.R")
```

## Data preparation
Before starting prepare the needed data, i.e. the ggm fit, the ranges originally
used and the original data.matrix. We als retrieve the different set of entities,
i.e. the snp, the cpgs as well as the respective locus genes, tfs and shortest path
genes. Those entities can either be selected via ggm graph or not.

```{r}
# prepare data
load("results/ggm.fit.full.RData")
data <- data.matrix
gnodes <- nodes(graph)
# for now, filter only for those nodes for which data was available
# should change once we update the data matrix...
gnodes <- gnodes[gnodes %in% colnames(data)]
# get names of all entities, total and selected by ggm
snp <- names(ranges$sentinel.range)
data[,snp] <- as.integer(as.character(data[,snp]))
cpgs <- names(ranges$cpgs)
cpgs.selected <- cpgs[cpgs %in% gnodes]
all.genes <- colnames(data)[!grepl("^rs|^cg", colnames(data))]
sgenes <- ranges$snp.genes$SYMBOL
sgenes.selected <- sgenes[sgenes %in% unlist(adj(graph,snp))]
cgenes <- ranges$cpg.genes$SYMBOL
cgenes.selected <- cgenes[cgenes %in% unlist(adj(graph,cpgs))]
tfs <- ranges$tfs$SYMBOL
tfs.selected <- tfs[tfs %in% unlist(adj(graph,cpgs))]
# the shortest path genes
spath <- ranges$spath.genes$SYMBOL
spath.selected <- spath[spath %in% gnodes]

cat("Summary on number of genes, total vs selected via ggm:\n")
cat("sgenes\t", length(sgenes),"\t", length(sgenes.selected), "\n")
cat("cgenes\t", length(cgenes),"\t", length(cgenes.selected), "\n")
cat("tfs\t", length(tfs),"\t", length(tfs.selected), "\n")
cat("spath\t", length(spath),"\t", length(spath.selected), "\n")

```
Above you see the number snp genes (sgenes), cpg genes (cgenes), transcription
factors (tfs) as well as the genes on the shortest paths between tfs and sgenes (spath).
Starting from those set definitions, we now perform the validation of the model.

## SNP-gene validtion
Now that all is prepared, we perform the SNP-gene validation for which we have several approaches:
1. perform gene mediation
2. check whether the selected genes are cis-eQTLs in an independent study
3. check whether SNPs are in TFBS (in case of >1 SNPs)
4. ChromHMM states for SNPs (in case of >1 SNPs)
concept.

To achieve this, we also load some additional data: 
* Joehanes et al. 2017 eQTL data

```{r}
# (1) load chromHMM annotation (SNP annotation)
## not yet needed
# (2) check cis-eQTL in independent study
# load cis-eQTL data
ceqtl <- fread("zcat data/joehanes-et-al-2017/eqtls/eqtl-gene-annot_cis-only.txt.gz",
               sep=",", 
               data.table=F, select = c("SNP_Chr","SNP_Pos_hg19","Rs_ID","SNP_MAF","SNP_Imputation_RSq","ProbesetID","Transcript_Chr","Transcript_GeneSymbol","Transcript_EntrezGeneID","Is_Cis","log10FDR"))
# get only cis eqtlas defined in the paper
ceqtl <- ceqtl[ceqtl$Is_Cis==1,,drop=F]
cat("Loaded ", nrow(ceqtl), " cis-eQTL\n")
head(ceqtl)

# filter teqtl to be only related to our sentinel SNP
# TODO use proxy/high ld snps to increase teqtl number?
ceqtl <- ceqtl[ceqtl$Rs_ID %in% snp,,drop=F]
ceqtl.sgenes <- sgenes[sgenes %in% ceqtl$Transcript_GeneSymbol]
ceqtl.sgenes.selected <- intersect(ceqtl.sgenes, sgenes.selected)
ceqtl.sgenes
ceqtl.sgenes.selected
# create matrix for fisher test
cont <- matrix(c(length(ceqtl.sgenes),length(ceqtl.sgenes.selected),
                 length(sgenes),length(sgenes.selected)),
               nrow=2,ncol=2, byrow = T)
rownames(cont) <- c("teqtl", "no teqtl")
colnames(cont) <- c("not selected", "selected")
cont
fisher.test(cont)

# (3) SNPs in TFBS
## not yet needed
# (4) Perform mediation analysis
# mediation over all snp genes
med <- mediation(data, snp, sgenes, cpgs )
# mediation for only ggm selected snp genes
med.selected <- med[sgenes.selected]
# mediation for only not selected snp genes
med <- med[setdiff(sgenes,sgenes.selected)]

# TODO if we choose to do a test for comparing 
# selected/not selected, check assumptions first

# mean mediation for all not selected snpgenes
med.cor <- (unlist(lapply(med, "[[", "pvalue")))
# mean mediation for selected snpgenes
med.cor.selected <- (unlist(lapply(med.selected, "[[", "pvalue")))

cat("Mediation result summary (mean of pvals):\n")
cat("not selected\tselected\n")
cat(mean(med.cor), "\t", mean(med.cor.selected))

```

## CpG-gene and TF-CpG validation
The next step is validating the cpg-gene and cpg-tf links. For this we use 3 approaches:
1. check trans-eQTL in independent dataset. Here we found the paper of [Joehanes et al. 2017
in Genome Biology](https://genomebiology.biomedcentral.com/articles/10.1186/s13059-016-1142-6)
2. check epigenetic annotation (implies change in currently performed prior calculation)
3. check CpGs in TFBS (split cell-lines for priors/validation).
```{r}
# load the trans-eQTL dataset
teqtl <- fread("zcat data/joehanes-et-al-2017/eqtls/eqtl-gene-annot_trans-only_logFDR2.txt.gz", 
               sep=",", 
               data.table=F, select = c("SNP_Chr","SNP_Pos_hg19","Rs_ID","SNP_MAF","SNP_Imputation_RSq","ProbesetID","Transcript_Chr","Transcript_GeneSymbol","Transcript_EntrezGeneID","Is_Cis","log10FDR"))
# sanity check
cat("only trans: ", all(teqtl$Is_Cis == 0), "\n")
head(teqtl)

# filter teqtl to be only related to our sentinel SNP
# TODO use proxy/high ld snps to increase teqtl number?
teqtl <- teqtl[teqtl$Rs_ID %in% snp,,drop=F]
teqtl.cgenes <- cgenes[cgenes %in% teqtl$Transcript_GeneSymbol]
teqtl.cgenes.selected <- intersect(teqtl.cgenes, cgenes.selected)

cat("CpG genes: ", cgenes, "\n")
cat("CpG genes with trans-eQTL: ", teqtl.cgenes, "\n")
cat("selected CpG genes with trans-eQTL: ", teqtl.cgenes.selected, "\n")

# create matrix for fisher test
cont <- matrix(c(length(teqtl.cgenes),length(teqtl.cgenes.selected),
                 length(cgenes),length(cgenes.selected)),
               nrow=2,ncol=2, byrow = T)
rownames(cont) <- c("teqtl", "no teqtl")
colnames(cont) <- c("not selected", "selected")
cont
fisher.test(cont)

# TODO analyze the tfs, total and selected
#teqtl.tfs <- tfs[tfs %in% teqtl$Transcript_GeneSymbol]
#teqtl.tfs.selected <- intersect[teqtl.tfs, tfs.selected]

#cat("TFs: ", tfs, "\n")
#cat("TFs with trans-eQTL: ", teqtl.tfs, "\n")
#cat("selected TFs with trans-eQTL: ", teqtl.tfs.selected, "\n")

```

## Gene-Gene validation
Finally we perform the gene-gene validation:
1. check co-expression in independent data. 
2. gene set enrichment
3. check co-citation 

For the co-expression analysis we load the data from Geuvadis (Lappaleinen et al.),
this is gene expression data from 462 LCL cell-lines. The data already is normalized
to RPKMs and technical artifacts are removed (using PEER factors). We currently
calculated correlations only on the subset of genes which is within our network.
```{r}
# load the expression data from geuvadis/lappaleinen
geu <- fread("zcat data/expression/GD462.GeneQuantRPKM.50FN.samplename.resk10.txt.gz", header=T,
             data.table=F)
geneinfo <- geu[,1:4]

# get the gene symbols
geneinfo$Gene_Symbol <- mapIds(Homo.sapiens, unlist(lapply(strsplit(geneinfo[,1], "\\."), "[",1)), "SYMBOL", keytype="ENSEMBL")
drop <- is.na(geneinfo$Gene_Symbol)
geneinfo <- geneinfo[!drop,]
geu <- geu[!drop,]
rpkm <- geu[,5:ncol(geu)]
samp <- fread("data/expression/patients_edit.txt", sep="\t", header=T,
              data.table=F)
# for now we skip filtering the samples and just calculate over all available
# samples. We could use this to manually adjust for covariates in the sample table
# however we use the already PEER normalized version of the gene expression
# rpkm <- rpkm[,colnames(rpkm) %in% samp$sample]

rpkm <- data.matrix(rpkm)
min(rpkm)
max(rpkm)

```
Dimension of the gene expression matrix is `r dim(rpkm)`. We first check the distribution
of the expression of some randomly selected genes.

```{r}
par(mfrow=c(2,2))
set.seed(42)
hist(rpkm[sample(1:nrow(rpkm),1),], breaks=50, xlab="rpkm", main="histogram 1")
hist(rpkm[sample(1:nrow(rpkm),1),], breaks=50, xlab="rpkm", main="histogram 2")
hist(rpkm[sample(1:nrow(rpkm),1),], breaks=50, xlab="rpkm", main="histogram 3")
hist(rpkm[sample(1:nrow(rpkm),1),], breaks=50, xlab="rpkm", main="histogram 4")
#TODO histogram shows few very large values -> handle?
```

Now, for each gene we calculate the correlation against each other gene in our set
over all samples. In the end we want to boil this down to 'significant' correlations,
hence we collect FDR corrected p-values using the psych package.

```{r}
# get the gene-gene links which are possible in our graph
em <- expand.grid(all.genes, all.genes, stringsAsFactors = F)
em <- (em[em$Var1 != em$Var2, ])
em <- cbind(em[,1], em[,2])
em

# get the gene-gene links which can be found in our graph
em.selected <- t(edgeMatrix(graph))
em.selected <- cbind(gnodes[em.selected[,1]], gnodes[em.selected[,2]])
em.selected <- em.selected[!grepl("^rs|^cg", em.selected[,1]),]
em.selected <- em.selected[!grepl("^rs|^cg", em.selected[,2]),]
colnames(em) <- colnames(em.selected) <- c("n1", "n2")

em
em.selected

# get the gene-gene sign correlations from the lappal. data
totest <- t(rpkm[geneinfo$Gene_Symbol %in% colnames(data),])
totest.symbols <- geneinfo[geneinfo$Gene_Symbol %in% colnames(data), "Gene_Symbol"]
if(any(duplicated(totest.symbols))){
  # TODO merge the data, i.e. take rpkm means or similar if necessary...
  warning("Not handling multiple entries for genes right now...")
}
colnames(totest) <- totest.symbols
cat("Checking ", ncol(totest), " genes for correlation.\n")
cors <- psych::corr.test(totest, adjust="BH", ci=F)
# upper diagonal of p contains the adjusted pvalues
hist(cors$p[upper.tri(cors$p)], main="pvalues of correlations between genes")

# TODO now we need to check the gene links which were selected against the ones which
# weren't...
# 
```


