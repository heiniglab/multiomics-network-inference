---
title: Replication validation based on reviewer comments
author: Johann Hawe | johann.hawe@tum.de
output:
  pdf_document: 
    toc: yes
  html_document: default
---

```{r setup, echo = FALSE, message = FALSE, warning = FALSE}
library(BDgraph)
library(igraph)
library(graph)
library(readr)
library(dplyr)
library(ggplot2)
library(parallel)
library(reshape2)
library(cowplot)
theme_set(theme_cowplot() + background_grid(major="xy"))

threads <- 4

knitr::opts_chunk$set(echo = FALSE)

```

## Load data

We load all previously generated data, including the collected priors and the
model fits for KORA and LOLIPOP.

```{r load_data}
fpriors <- 
  list.files("results/current/biogrid_stringent/priors/", 
             "*.rds", full.names = T)
fkora_fits <- 
  list.files("results/current/biogrid_stringent/fits_tfa/_rerun/kora/", 
             "*.rds", full.names = T)
flolipop_fits <- 
  list.files("results/current/biogrid_stringent/fits_tfa/_rerun/lolipop/", 
             "*.rds", full.names = T)

rename_files <- function(file_list) {
  names(file_list) <- gsub(".rds", "", gsub(".*/", "", file_list))
  file_list
}

fpriors <- rename_files(fpriors)
fkora_fits <- rename_files(fkora_fits)
flolipop_fits <- rename_files(flolipop_fits)

sentinels <- names(fpriors)
```

- Number of sentinels to be processed: `r length(sentinels)`

## Prior importance for replication

```{r helper_definitions, echo = FALSE}
PSEUDO_PRIOR <- 1e-7

# helper to extract prior edge/non edge sets
get_prior_edge_sets <- function(prior_matrix) {
  
  prior_matrix_tibble <- prior_matrix %>%
    melt() %>% as_tibble()
  
  prior_edges <-  prior_matrix_tibble %>%
    filter(value > PSEUDO_PRIOR) %>%
    rename(edge1 = Var1, edge2 = Var2) %>%
    mutate(edge1 = as.character(edge1), edge2 = as.character(edge2)) %>%
    filter(edge1 != edge2) %>%
    dplyr::select(-value)
  
  non_prior_edges <- prior_matrix_tibble %>%
    filter(value == PSEUDO_PRIOR) %>%
    rename(edge1 = Var1, edge2 = Var2) %>%
    mutate(edge1 = as.character(edge1), edge2 = as.character(edge2)) %>%
    filter(edge1 != edge2) %>%
    dplyr::select(-value)
  return(list(prior_edges = prior_edges, non_prior_edges = non_prior_edges))
}

# helper to get tibble of edges from a graph object
get_edges_from_graph <- function(graph) {
  graph_nodes <- nodes(graph)
  temp <- t(graph::edgeMatrix(graph)) %>%
    as_tibble() %>%
    mutate(from = graph_nodes[from],
           to = graph_nodes[to]) %>%
    rename(edge1 = from, edge2 = to)
  
  # add the 'reverse' edge, too, as we investigated undirected graphs
  bind_rows(temp, rename(temp, edge1 = edge2, edge2 = edge1))
}
```

We investigate whether available prior information largely drives replication performance.
In brief, we create a contingency table from all sentinels, where we check 1) whether an edge is replicated or not and 2) whether the edge has a prior assigned it or not.

```{r prior_importance_replication}
# iterate over all sentinels and gather stats
result <- mclapply(sentinels, function(sentinel) {
  
  prior_matrix <- readRDS(fpriors[[sentinel]])
  temp <- get_prior_edge_sets(prior_matrix)
  prior_edges <- temp$prior_edges
  non_prior_edges <- temp$non_prior_edges
  
  kora_fits <- readRDS(fkora_fits[[sentinel]])
  lolipop_fits <- readRDS(flolipop_fits[[sentinel]])
  
  graph_models <- names(kora_fits)[!grepl("_fit", names(kora_fits))]
  
  lapply(graph_models, function(graph_model) {
    kora_edges <- get_edges_from_graph(kora_fits[[graph_model]])
    lolipop_edges <- get_edges_from_graph(lolipop_fits[[graph_model]])
    
    replicated_edges <- inner_join(kora_edges, lolipop_edges,
                                   by=c("edge1", "edge2")) 
    
    # we always have both 'directions' for the undirected edges in the tibbles
    # devide measures by 2
    prior_and_replicated <- 
      nrow(inner_join(prior_edges, replicated_edges,
                      by=c("edge1", "edge2"))) / 2
    
    prior_not_replicated <- 
      (nrow(prior_edges) / 2) - prior_and_replicated
    
    not_prior_and_replicated <- 
      nrow(inner_join(non_prior_edges, replicated_edges,
                      by=c("edge1", "edge2"))) / 2
    
    not_prior_not_replicated <- 
      (nrow(non_prior_edges) / 2) - not_prior_and_replicated
    
    contingency <- matrix(c(prior_and_replicated, 
                            prior_not_replicated,
                            not_prior_and_replicated,
                            not_prior_not_replicated), 
                          ncol=2, byrow = T)
    
    fisher.test(contingency, alternative = "greater") %>% broom::tidy() %>%
      mutate(graph_model = graph_model,
             prior_and_replicated = prior_and_replicated,
             prior_not_replicated = prior_not_replicated,
             not_prior_and_replicated = not_prior_and_replicated,
             not_prior_not_replicated = not_prior_not_replicated) %>% 
      dplyr::select(graph_model, -method, -alternative, everything())
  }) %>% bind_rows() %>%
    mutate(sentinel = sentinel) %>%
    dplyr::select(sentinel, everything())
}, mc.cores = 4) %>% bind_rows() %>%
    mutate(is_prior_based = case_when(graph_model %in% c("glasso", 
                                                         "bdgraph", 
                                                         "irafnet") ~ TRUE,
                                    TRUE ~ FALSE))
result

ggplot(result %>% mutate(estimate = case_when(is.infinite(estimate) ~ 1e4, 
                                              TRUE ~ estimate)), 
       aes(x=log10(estimate), 
           group=is_prior_based, 
           color=is_prior_based)) + 
  geom_freqpoly()
```

Above are the initial 'full' results, i.e. for each graph model and sentinel,
we see the evaluation by use of the fisher test.

The plot indicates the distribution (log10) of estimates over all models and sentinels.
`estimates` amounging to `Inf` were substituted by `10e4` and result in the 
peaks located at the far right of the plot.

Now we look at a simple summary, where we sum up all contingency tables and
calculate a single fisher test for each of the graph models.

```{r prior_importance_replication_summarized}
summarized <- group_by(result, graph_model) %>%
  summarize(prior_and_replicated = sum(prior_and_replicated),
             prior_not_replicated = sum(prior_not_replicated),
             not_prior_and_replicated = sum(not_prior_and_replicated),
             not_prior_not_replicated = sum(not_prior_not_replicated))

summarized_fishertest <- lapply(summarized$graph_model, function(current_model) {
  current_summarized <-
    filter(summarized, graph_model == current_model)
  
  contingency_summarized <-
    matrix(
      c(
        current_summarized$prior_and_replicated,
        current_summarized$prior_not_replicated,
        current_summarized$not_prior_and_replicated,
        current_summarized$not_prior_not_replicated
      ),
      ncol = 2,
      byrow = TRUE
    )
  fisher.test(contingency_summarized, alternative = "greater") %>% 
    broom::tidy() %>%
    mutate(graph_model = current_model) %>%
    dplyr::select(graph_model, everything())
}) %>% bind_rows() %>%
  left_join(summarized, by="graph_model") %>%
  mutate(is_prior_based = case_when(graph_model %in% c("glasso", 
                                                       "bdgraph", 
                                                       "irafnet") ~ TRUE,
                                    TRUE ~ FALSE))

summarized_fishertest

ggplot(summarized_fishertest, aes(y=log10(estimate), 
                                  x=reorder(graph_model, log10(estimate)),
                                  fill = is_prior_based)) + 
  geom_bar(stat="identity") + 
  theme(axis.text.x = element_text(angle=-45, hjust=0, vjust=0)) + 
  labs(x="graph model")
```

## Prior importance inferred edge set

Contrary to the replicated edge set above, we can also have a look at the 'inferred' edge set,
which are defined as the union of the edge sets from KORA and LOLIPOP.

```{r prior_importance_inferred_edgeset}
PSEUDO_PRIOR <- 1e-7


# iterate over all sentinels and gather stats
result <- mclapply(sentinels, function(sentinel) {
  
  prior_matrix <- readRDS(fpriors[[sentinel]])
  temp <- get_prior_edge_sets(prior_matrix)
  prior_edges <- temp$prior_edges
  non_prior_edges <- temp$non_prior_edges
  
  kora_fits <- readRDS(fkora_fits[[sentinel]])
  lolipop_fits <- readRDS(flolipop_fits[[sentinel]])
  
  graph_models <- names(kora_fits)[!grepl("_fit", names(kora_fits))]
  
  lapply(graph_models, function(graph_model) {
    kora_edges <- get_edges_from_graph(kora_fits[[graph_model]])
    lolipop_edges <- get_edges_from_graph(lolipop_fits[[graph_model]])
    
    full_edge_set <- bind_rows(kora_edges, lolipop_edges) %>%
      distinct()
    
    # we always have both 'directions' for the undirected edges in the tibbles
    # devide measures by 2
    prior_and_inferred <- 
      nrow(inner_join(prior_edges, full_edge_set,
                      by=c("edge1", "edge2"))) / 2
    
    prior_not_inferred <- 
      (nrow(prior_edges) / 2) - prior_and_inferred
    
    not_prior_and_inferred <- 
      nrow(inner_join(non_prior_edges, full_edge_set,
                      by=c("edge1", "edge2"))) / 2
    
    not_prior_not_inferred <- 
      (nrow(non_prior_edges) / 2) - not_prior_and_inferred
    
    contingency <- matrix(c(prior_and_inferred, 
                            prior_not_inferred,
                            not_prior_and_inferred,
                            not_prior_not_inferred), 
                          ncol=2, byrow = T)
    
    fisher.test(contingency, alternative = "greater") %>% broom::tidy() %>%
      mutate(graph_model = graph_model,
             prior_and_inferred = prior_and_inferred,
             prior_not_inferred = prior_not_inferred,
             not_prior_and_inferred = not_prior_and_inferred,
             not_prior_not_inferred = not_prior_not_inferred) %>% 
      dplyr::select(graph_model, -method, -alternative, everything())
  }) %>% bind_rows() %>%
    mutate(sentinel = sentinel) %>%
    dplyr::select(sentinel, everything())
}, mc.cores = 4) %>% bind_rows() %>%
    mutate(is_prior_based = case_when(graph_model %in% c("glasso", 
                                                       "bdgraph", 
                                                       "irafnet") ~ TRUE,
                                    TRUE ~ FALSE))
result

ggplot(result %>% mutate(estimate = case_when(is.infinite(estimate) ~ 1e4, 
                                              TRUE ~ estimate)), 
       aes(x=log10(estimate), 
           group=is_prior_based, 
           color=is_prior_based)) + 
  geom_freqpoly()

```

```{r prior_importance_inferred_summarized}
summarized <- group_by(result, graph_model) %>%
  summarize(prior_and_inferred = sum(prior_and_inferred),
             prior_not_inferred = sum(prior_not_inferred),
             not_prior_and_inferred = sum(not_prior_and_inferred),
             not_prior_not_inferred = sum(not_prior_not_inferred))

summarized_fishertest <- lapply(summarized$graph_model, function(current_model) {
  current_summarized <-
    filter(summarized, graph_model == current_model)
  
  contingency_summarized <-
    matrix(
      c(
        current_summarized$prior_and_inferred,
        current_summarized$prior_not_inferred,
        current_summarized$not_prior_and_inferred,
        current_summarized$not_prior_not_inferred
      ),
      ncol = 2,
      byrow = TRUE
    )
  fisher.test(contingency_summarized, alternative = "greater") %>% 
    broom::tidy() %>%
    mutate(graph_model = current_model) %>%
    dplyr::select(graph_model, everything())
}) %>% bind_rows() %>%
  left_join(summarized, by="graph_model") %>%
  mutate(is_prior_based = case_when(graph_model %in% c("glasso", 
                                                       "bdgraph", 
                                                       "irafnet") ~ TRUE,
                                    TRUE ~ FALSE))

summarized_fishertest

ggplot(summarized_fishertest, aes(y=log10(estimate), 
                                  x=reorder(graph_model, log10(estimate)),
                                  fill = is_prior_based)) + 
  geom_bar(stat="identity") + 
  theme(axis.text.x = element_text(angle=-45, hjust=0, vjust=0)) + 
  labs(x="graph model")
```

## Session Info
```{r session_info}
devtools::session_info()
```
