---
title: Replication validation based on reviewer comments
author: Johann Hawe | johann.hawe@tum.de
output:
  pdf_document: 
    toc: yes
  html_document: default
---

```{r setup, echo = FALSE, message = FALSE, warning = FALSE}
library(BDgraph)
library(igraph)
library(graph)
library(readr)
library(dplyr)
library(ggplot2)
library(parallel)
library(reshape2)
library(cowplot)
theme_set(theme_cowplot() + background_grid(major="xy"))

threads <- 4

knitr::opts_chunk$set(echo = FALSE)

```

## Load data

We load all previously generated data, including the collected priors and the
model fits for KORA and LOLIPOP.

```{r load_data}
fpriors <- 
  list.files("results/current/biogrid_stringent/priors/", 
             "*.rds", full.names = T)
fkora_fits <- 
  list.files("results/current/biogrid_stringent/fits_tfa/_rerun/kora/", 
             "*.rds", full.names = T)
flolipop_fits <- 
  list.files("results/current/biogrid_stringent/fits_tfa/_rerun/lolipop/", 
             "*.rds", full.names = T)

rename_files <- function(file_list) {
  names(file_list) <- gsub(".rds", "", gsub(".*/", "", file_list))
  file_list
}

fpriors <- rename_files(fpriors)
fkora_fits <- rename_files(fkora_fits)
flolipop_fits <- rename_files(flolipop_fits)

sentinels <- names(fpriors)
```

- Number of sentinels to be processed: `r length(sentinels)`

## Prior importance for replication

We investigate whether available prior information largely drives replication performance.
In brief, we create a contingency table from all sentinels, where we check 1) whether an edge is replicated or not and 2) whether the edge has a prior assigned it or not.

```{r prior_importance_replication}
PSEUDO_PRIOR <- 1e-7

# helper to get tibble of edges from a graph object
get_edges_from_graph <- function(graph) {
  graph_nodes <- nodes(graph)
  temp <- t(graph::edgeMatrix(graph)) %>%
    as_tibble() %>%
    mutate(from = graph_nodes[from],
           to = graph_nodes[to]) %>%
    rename(edge1 = from, edge2 = to)
  
  # add the 'reverse' edge, too, as we investigated undirected graphs
  bind_rows(temp, rename(temp, edge1 = edge2, edge2 = edge1))
}

# iterate over all sentinels and gather stats
result <- mclapply(sentinels, function(sentinel) {
  
  prior_edges <- readRDS(fpriors[[sentinel]]) %>%
    melt() %>% as_tibble() %>%
    filter(value > PSEUDO_PRIOR) %>%
    rename(edge1 = Var1, edge2 = Var2) %>%
    mutate(edge1 = as.character(edge1), edge2 = as.character(edge2)) %>%
    filter(edge1 != edge2) %>%
    dplyr::select(-value)
  
  non_prior_edges <- readRDS(fpriors[[sentinel]]) %>%
    melt() %>% as_tibble() %>%
    filter(value == PSEUDO_PRIOR) %>%
    rename(edge1 = Var1, edge2 = Var2) %>%
    mutate(edge1 = as.character(edge1), edge2 = as.character(edge2)) %>%
    filter(edge1 != edge2) %>%
    dplyr::select(-value)
  
  kora_fits <- readRDS(fkora_fits[[sentinel]])
  lolipop_fits <- readRDS(flolipop_fits[[sentinel]])
  
  graph_models <- names(kora_fits)[!grepl("_fit", names(kora_fits))]
  
  lapply(graph_models, function(graph_model) {
    kora_edges <- get_edges_from_graph(kora_fits[[graph_model]])
    lolipop_edges <- get_edges_from_graph(lolipop_fits[[graph_model]])
    
    replicated_edges <- inner_join(kora_edges, lolipop_edges,
                                   by=c("edge1", "edge2")) 
    
    # we always have both 'directions' for the undirected edges in the tibbles
    # devide measures by 2
    prior_and_replicated <- 
      nrow(inner_join(prior_edges, replicated_edges,
                      by=c("edge1", "edge2"))) / 2
    
    prior_not_replicated <- 
      (nrow(prior_edges) / 2) - prior_and_replicated
    
    not_prior_and_replicated <- 
      nrow(inner_join(non_prior_edges, replicated_edges,
                      by=c("edge1", "edge2"))) / 2
    
    not_prior_not_replicated <- 
      (nrow(non_prior_edges) / 2) - not_prior_and_replicated
    
    contingency <- matrix(c(prior_and_replicated, 
                            prior_not_replicated,
                            not_prior_and_replicated,
                            not_prior_not_replicated), 
                          ncol=2, byrow = T)
    
    fisher.test(contingency, alternative = "greater") %>% broom::tidy() %>%
      mutate(graph_model = graph_model,
             prior_and_replicated = prior_and_replicated,
             prior_not_replicated = prior_not_replicated,
             not_prior_and_replicated = not_prior_and_replicated,
             not_prior_not_replicated = not_prior_not_replicated) %>% 
      dplyr::select(graph_model, -method, -alternative, everything())
  }) %>% bind_rows() %>%
    mutate(sentinel = sentinel) %>%
    dplyr::select(sentinel, everything())
}, mc.cores = 4) %>% bind_rows() %>%
    mutate(is_prior_based = case_when(graph_model %in% c("glasso", 
                                                       "bdgraph", 
                                                       "irafnet") ~ TRUE,
                                    TRUE ~ FALSE))
result

ggplot(result %>% mutate(estimate = case_when(is.infinite(estimate) ~ 1e4, 
                                              TRUE ~ estimate)), 
       aes(x=log10(estimate), 
           group=is_prior_based, 
           color=is_prior_based)) + 
  geom_freqpoly()
```

Above are the initial 'full' results, i.e. for each graph model and sentinel,
we see the evaluation by use of the fisher test.

The plot indicates the distribution (log10) of estimates over all models and sentinels.
`estimates` amounging to `Inf` were substituted by `10e4` and result in the 
peaks located at the far right of the plot.

Now we look at a simple summary, where we sum up all contingency tables and
calculate a single fisher test for each of the graph models.

```{r prior_importance_replication_summarized}
summarized <- group_by(result, graph_model) %>%
  summarize(prior_and_replicated = sum(prior_and_replicated),
             prior_not_replicated = sum(prior_not_replicated),
             not_prior_and_replicated = sum(not_prior_and_replicated),
             not_prior_not_replicated = sum(not_prior_not_replicated))

summarized_fishertest <- lapply(summarized$graph_model, function(current_model) {
  current_summarized <-
    filter(summarized, graph_model == current_model)
  
  contingency_summarized <-
    matrix(
      c(
        current_summarized$prior_and_replicated,
        current_summarized$prior_not_replicated,
        current_summarized$not_prior_and_replicated,
        current_summarized$not_prior_not_replicated
      ),
      ncol = 2,
      byrow = TRUE
    )
  fisher.test(contingency_summarized, alternative = "greater") %>% 
    broom::tidy() %>%
    mutate(graph_model = current_model) %>%
    dplyr::select(graph_model, everything())
}) %>% bind_rows() %>%
  left_join(summarized, by="graph_model") %>%
  mutate(is_prior_based = case_when(graph_model %in% c("glasso", 
                                                       "bdgraph", 
                                                       "irafnet") ~ TRUE,
                                    TRUE ~ FALSE))

summarized_fishertest

ggplot(summarized_fishertest, aes(y=log10(estimate), 
                                  x=reorder(graph_model, log10(estimate)),
                                  fill = is_prior_based)) + 
  geom_bar(stat="identity") + 
  theme(axis.text.x = element_text(angle=-45, hjust=0, vjust=0)) + 
  labs(x="graph model")
```


## Session Info
```{r session_info}
devtools::session_info()
```
