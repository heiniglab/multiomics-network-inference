---
title: "Apply bayesian Graphical Models to multi-omics data"
output: html_notebook
author: Johann Hawe
params:
  SNP: ""
---
```{r}
if(params$SNP=="") stop("No sentinel provided!")
sentinel <- params$SNP
```

In this script we load KORA and LOLIPOP data for the `r params$SNP` sentinel and 
apply the bayesian GGM algorithm implemented in the BDgraph package to them, 
using priors for the individual links possible in the underlying graph structure. 
Priors have to be created beforehand and provided as RData files on the results folder.

```{r, message=FALSE, include=FALSE}
# first load the custom BDgraph library
library(BDgraph, lib.loc="/storage/groups/groups_epigenereg/packages/2017/R/3.4/")
library(pheatmap)
library(GenomicRanges)
library(igraph)
library(graph)

# source the library scripts
source("R/lib.R")
source("R/priors.R")

# define the available cohorts
cohorts <- c("lolipop", "kora")
```

## Data preparation
First we load the data for both cohorts (LOLIPOP and KORA). For this we load the
preprocessed data from the original meQTL script and adjust it to better fit our
needs.

```{r}
sentinel <- params$SNP
sentinel <- "rs9859077"
data <- lapply(cohorts, function(c){
  # load data into new environment
  env <- new.env()
  load(paste0("data/", c, "/", sentinel, ".data.RData"), envir=env)
  ggm.data <- with(env, sentinel)
  id <- with(env, id)
  data <- ggm.data$data
  # handle NA cpgs
  filter.nas <- function(d){
    rm <- unlist(apply(d,2,function(x) {sum(is.na(x))>5}))
    d <- d[,!rm]
    d <- d[complete.cases(d),]
    return(d)
  }
  data <- filter.nas(data)
  cat("Data dimension for", c, ":", dim(data))
  nodes <- colnames(data)
  ranges <- ggm.data
  ranges$data <- NULL
  ranges$cpg.genes <- ranges$cpg.genes[(ranges$cpg.genes$SYMBOL) %in% nodes]
  ranges$snp.genes <- ranges$snp.genes[(ranges$snp.genes$SYMBOL) %in% nodes]
  ranges$spath <- ranges$spath[ranges$spath$SYMBOL %in% nodes]
  ranges$tfs <- ranges$tfs[ranges$tfs$SYMBOL %in% nodes]
  return(list(id=id, data=data, ranges=ranges, nodes=nodes))
})
names(data) <- cohorts
```

## Prior calculation
Now we get the priors for all possible links within the data matrix. The priors
need to have been created beforehand and are simply loaded in the called function.

```{r cache=TRUE, collapse=T}
priors <- lapply(cohorts, function(c){
  cohort <- data[[c]]
  
  # get the prior definitions and plot the prior heatmap
  priors <- get.link.priors(cohort$ranges, cohort$nodes)
  cat("Prior min-value: ", min(priors), "\n")
  
  pheatmap(priors, cex=0.7, main=paste0(c, " priors"))
  return(priors)
})
names(priors) <- cohorts
```

## GGM fit
In the next step we finally fit the GGM to our data, using the priors during 
the process. First a 'start-graph' is created, which serves as the entry point
in the calculations for the algorithms. Afterwards we can start running the 
bdgraph algorithm in order to get our partial correlations based on data and prior knowledge. 

```{r echo=F, collapse=T}
gstarts <- lapply(cohorts, function(c){
  # create start graph
  g.start <- get.g.start.from.priors(priors[[c]])
  pheatmap(g.start, cex=0.7, main=paste0(c, " start graph"))
  return(g.start)
})
names(gstarts) <- cohorts
```

```{r}
iter=100000
burnin=5000
cores=8
```
We use `r iter` iterations with a burnin of `r burnin` as well as a total of
`r cores` cores. We then extract the graph from the ggm fit and create a dot file
representing the graph. If the graph is less then 500 edges it will be plotted graphically
as well.
In addition, we create some diagnostic plots to check the convergence of the 
algorithm.

```{r cache=T, results=F}
fits <- lapply(cohorts, function(c){
  gdata <- data[[c]]$data
  id <- data[[c]]$id
  ranges <- data[[c]]$ranges
  gstart <- gstarts[[c]]
  gpriors <- priors[[c]]
  ggm.fit <- bdgraph(gdata, 
          method="gcgm", 
          iter=iter, 
          burnin=burnin,
          save.all=T, g.start = gstart,
          g.prior = gpriors, cores=cores)
  
  graph <- graph.from.fit(ggm.fit, ranges)
  if(length(nodes(graph))<1){
    warning("Resulting graph has no nodes.")
  } else {
    
    plot.data <- plot.ggm(g=graph, id=id, dot.out = paste0("results/", params$SNP, ".", c, ".fit.dot"))
    save(file=paste0("results/", params$SNP, ".", c, ".fit.RData"), 
         ggm.fit, ranges, gdata, gstart, gpriors, graph, plot.data)
  }
  # check some plots
  ggm.summary <- summary(ggm.fit)
  traceplot(ggm.fit)
  plotcoda(ggm.fit)
  return(list(ggm.fit = ggm.fit, graph=graph, summary = ggm.summary))
})
names(fits) <- cohorts
# save fits extra, although this is a bit redundant
save(file=paste0("results/", params$SNP, ".fits.RData"), fits)
```
